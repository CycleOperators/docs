<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- cursor Session a286a54c-474a-45a9-9acc-6704710bc8c9 (2025-11-10 20:07Z) -->

# Automating canister deployments with CycleOps (2025-11-10 20:07Z)

_**User (2025-11-10 19:45Z)**_

I want us to add a new @changelog 



## Automate Your Canister Deployments with CycleOps and ic-deploy-actions: 



Steve Kimoi 

Developer / ICP Contributor

Hi there, I am Steve Kimoi, a seasoned ICP developer who has worked in different developer toolkits such as [generate-did crate](https://crates.io/crates/generate-did), [DNS Config Generator](https://canisterdns.stevekimoi.me/) and many other toolkits. 

Today, let’s look at how to make your Internet Computer deployments faster and easier.

 

--- 

Continuous delivery just got a whole lot easier on the Internet Computer.

With CycleOps and the ``ic-deploy-actions`` GitHub Action, you can automatically build and deploy your canisters every time you push to your main branch — no more switching to the terminal to run dfx deploy manually.

## What We Shipped: 

You can now easily automate your deployments to Internet Computer with these simple steps using [ic-deploy-actions](https://github.com/Stephen-Kimoi/ic-deploy-action) and CycleOps

Here’s what this means:

- Automatically build, deploy, and monitor canisters whenever you push to main.

- Secure authentication using PEM keys — no storing private credentials in plain text.

- Deploy one or multiple canisters depending on your workflow.

- A clean, repeatable, and reliable deployment process that just works.

## Why It Matters:

Before this setup, deploying to the Internet Computer usually meant one of two things:

1. Running ``dfx deploy --network`` ic manually each time you shipped code, or

2. Manually wiring up GitHub Actions to run your own scripts.

Both work, but they don’t scale well once you’re working in teams or managing multiple canisters.

By combining **CycleOps** and **ic-deploy-actions**, you can:

- Use the same GitHub CI/CD workflow you’re already familiar with.

- Keep deployment logic in version control, right alongside your code.

- Avoid mistakes that come from manual deploys — every build follows the same process.

It’s a lightweight setup that gives you confidence your code is always up-to-date on mainnet.

## How You Can Use It: 

### 1. Create or Add a Canister

Create a canister on CycleOps dashboard, check out the full documentation [here](https://docs.cycleops.dev/changelog/canister-creation)

[Create a canister](./images/create-a-canister.png)

Once you've created the canister, on your local machine, do an initial one-time deployment to mainnet, to ensure the canister has code.

### 2. Set Up ic-deploy-actions: 

In your directory, create a workflow file e.g ``(e.g. .github/workflows/deploy.yml)``

Paste in the following

```yml

name: Deploy to IC

on:

  push:

    branches: [ main ]

  workflow_dispatch:

jobs:

  deploy:

    runs-on: ubuntu-latest

    steps:

      - uses: actions/checkout@v3

      - name: Deploy to IC

        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1

        with:

            pem_key: ${{ secrets.IC_PEM_KEY }}

            network: 'ic'

            canister_name: 'your_backend_canister_name'

            deploy_frontend: 'true'

            deploy_backend: 'true'

            frontend_dir: 'src/your_frontend_dir/dist'

            backend_package: 'your_backend_package'

            frontend_package: 'your_frontend_package'

            frontend_src_dir: 'src/your_frontend_dir'

```

Generate a PEM key and add to GitHub Secrets

```

dfx identity new test-identity --storage-mode=plaintext

dfx identity export test-identity > test-identity.pem

base64 -i test-identity.pem > test-identity.pem.base64

```

Add the base64 content to your repo secrets as ``IC_PEM_KEY``.

Check out the full documentation [here](https://github.com/Stephen-Kimoi/ic-deploy-action?tab=readme-ov-file#internet-computer-icp-deploy-action)

---

That’s it — every push to your main branch will now trigger a deploy to the Internet Computer automatically.

CycleOps takes care of the monitoring and management, while ic-deploy-actions handles the build and deployment pipeline. 

--- 

### ✅ Ready to try it?

1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)

2. Add [ic-deploy-actions](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo

3. Push to main and watch your deployment go live





---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Checking changelog structure**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking new folder and file format**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/2025-06-10-canister-history/index.mdx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking authors.yml file**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/authors.yml</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding author and post metadata**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/2025-06-23-icp-ninja/index.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing new blog post structure**

I'm figuring out how to handle the missing image and adapting the content to either reference a placeholder or remove the broken link. I'll create a new folder with an index.mdx containing front matter like slug, title, and authors, plus add the requested sections and CTA, making sure to add the truncate marker after the intro. I'll also update authors.yml with the new author and manage folder creation and file addition through terminal commands and patch applications.</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/la/Cycle-Ops/docs && mkdir -p changelog/2025-11-10-automate-canister-deployments</summary>

```bash
cd /Users/la/Cycle-Ops/docs && mkdir -p changelog/2025-11-10-automate-canister-deployments
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing new index.mdx content**

I'm putting together the front matter for the new index.mdx, deciding on how to handle the image field since there's no specific image yet—probably best to reuse an existing general image to avoid broken links. I’ll also add a new author entry for Steve in authors.yml with his GitHub URL and role information to keep everything consistent.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/authors.yml&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;dda7d16e-856b-42c5-a799-d28e15bc454d&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;    url: https://github.com/q-uint\n    image_url: /img/authors/quint.png\n+ \n+ steve:\n+   name: Steve Kimoi\n+   title: Developer / ICP Contributor\n+   url: https://github.com/Stephen-Kimoi\n+   image_url: /img/cycleops.png\n  &quot;,
        &quot;oldStart&quot;: 22,
        &quot;newStart&quot;: 22,
        &quot;oldLines&quot;: 3,
        &quot;newLines&quot;: 9,
        &quot;linesAdded&quot;: 6
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/authors.yml&quot;,
  &quot;contentsAfterEdit&quot;: &quot;cycleops:\n  name: CycleOps Team\n  title: CycleOps Development Team\n  url: https://cycleops.dev\n  image_url: /img/cycleops.png\n\njorgen:\n  name: Jorgen Hookham\n  title: Developer\n  url: https://github.com/jorgenhookham\n  image_url: /img/authors/jorgen.png\n\nbyron:\n  name: Byron Becker\n  title: Developer\n  url: https://github.com/ByronBecker\n  image_url: /img/authors/byron.png\n\nquint:\n  name: Quint Daenen\n  title: Developer\n  url: https://github.com/q-uint\n  image_url: /img/authors/quint.png\n\nsteve:\n  name: Steve Kimoi\n  title: Developer / ICP Contributor\n  url: https://github.com/Stephen-Kimoi\n  image_url: /img/cycleops.png\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Composing new index.mdx content**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;d34c57aa-0354-4544-81eb-873a2ca6a9fe&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ ---\n+ slug: automate-canister-deployments\n+ title: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\n+ authors: [steve]\n+ ---\n+ \n+ Hi there, I’m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I’m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n+ \n+ &lt;!-- truncate --&gt;\n+ \n+ Continuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project—no more terminal hops or manual &#96;dfx deploy&#96;.\n+ \n+ ## What We Shipped\n+ \n+ - One-click automation: combine CycleOps with &#96;ic-deploy-actions&#96; to build, deploy, and watch canisters on every push.\n+ - Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n+ - Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.\n+ - Repeatable delivery: every merge follows the same scripted path, so production stays consistent.\n+ \n+ ## Why It Matters\n+ \n+ Manual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n+ \n+ ## How You Can Use It\n+ \n+ ### 1. Create or Add a Canister in CycleOps\n+ \n+ - Spin up the canister from your CycleOps dashboard—full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n+ - Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n+ \n+ ### 2. Wire Up &#96;ic-deploy-actions&#96;\n+ \n+ Create &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n+ \n+ &#96;&#96;&#96;yml\n+ name: Deploy to IC\n+ \n+ on:\n+   push:\n+     branches: [main]\n+   workflow_dispatch:\n+ \n+ jobs:\n+   deploy:\n+     runs-on: ubuntu-latest\n+     steps:\n+       - uses: actions/checkout@v3\n+       - name: Deploy to IC\n+         uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n+         with:\n+           pem_key: ${{ secrets.IC_PEM_KEY }}\n+           network: ic\n+           canister_name: your_backend_canister_name\n+           deploy_frontend: \&quot;true\&quot;\n+           deploy_backend: \&quot;true\&quot;\n+           frontend_dir: src/your_frontend_dir/dist\n+           backend_package: your_backend_package\n+           frontend_package: your_frontend_package\n+           frontend_src_dir: src/your_frontend_dir\n+ &#96;&#96;&#96;\n+ \n+ Generate a PEM key and add it to your GitHub secrets:\n+ \n+ &#96;&#96;&#96;bash\n+ dfx identity new cicd-identity --storage-mode=plaintext\n+ dfx identity export cicd-identity &gt; cicd-identity.pem\n+ base64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n+ &#96;&#96;&#96;\n+ \n+ Copy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you’re done.\n+ \n+ That’s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n+ \n+ ---\n+ \n+ ### ✅ Ready to try it?\n+ \n+ 1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n+ 2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n+ 3. Push to &#96;main&#96; and watch your deployment go live\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 81,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 81
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\nHi there, I’m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I’m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n&lt;!-- truncate --&gt;\n\nContinuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project—no more terminal hops or manual &#96;dfx deploy&#96;.\n\n## What We Shipped\n\n- One-click automation: combine CycleOps with &#96;ic-deploy-actions&#96; to build, deploy, and watch canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.\n- Repeatable delivery: every merge follows the same scripted path, so production stays consistent.\n\n## Why It Matters\n\nManual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard—full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you’re done.\n\nThat’s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying ASCII compliance**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Cleaning up punctuation and whitespace**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;1615eb0d-e808-4243-a836-c5d90cd7e876&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  ---\n  \n- Hi there, I’m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I’m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n+ Hi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n  \n  &lt;!-- truncate --&gt;&quot;,
        &quot;oldStart&quot;: 5,
        &quot;newStart&quot;: 5,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;  &#96;&#96;&#96;\n  \n- Copy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you’re done.\n+ Copy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n  \n- That’s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n+ That&#39;s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n  \n  ---&quot;,
        &quot;oldStart&quot;: 68,
        &quot;newStart&quot;: 68,
        &quot;oldLines&quot;: 7,
        &quot;newLines&quot;: 7,
        &quot;linesRemoved&quot;: 2,
        &quot;linesAdded&quot;: 2
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n&lt;!-- truncate --&gt;\n\nContinuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project—no more terminal hops or manual &#96;dfx deploy&#96;.\n\n## What We Shipped\n\n- One-click automation: combine CycleOps with &#96;ic-deploy-actions&#96; to build, deploy, and watch canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.\n- Repeatable delivery: every merge follows the same scripted path, so production stays consistent.\n\n## Why It Matters\n\nManual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard—full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking em dash replacement**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;50e09419-4ad1-4ebc-9854-58c6382e8d2d&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  &lt;!-- truncate --&gt;\n  \n- Continuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project—no more terminal hops or manual &#96;dfx deploy&#96;.\n+ Continuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project - no more terminal hops or manual &#96;dfx deploy&#96;.\n  \n  ## What We Shipped&quot;,
        &quot;oldStart&quot;: 9,
        &quot;newStart&quot;: 9,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;  ### 1. Create or Add a Canister in CycleOps\n  \n- - Spin up the canister from your CycleOps dashboard—full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n+ - Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n  - Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n  &quot;,
        &quot;oldStart&quot;: 26,
        &quot;newStart&quot;: 26,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;  Copy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n  \n- That&#39;s it—every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n+ That&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n  \n  ---&quot;,
        &quot;oldStart&quot;: 70,
        &quot;newStart&quot;: 70,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n&lt;!-- truncate --&gt;\n\nContinuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and &#96;ic-deploy-actions&#96; running in GitHub, every push to &#96;main&#96; can build, deploy, and monitor your project - no more terminal hops or manual &#96;dfx deploy&#96;.\n\n## What We Shipped\n\n- One-click automation: combine CycleOps with &#96;ic-deploy-actions&#96; to build, deploy, and watch canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.\n- Repeatable delivery: every merge follows the same scripted path, so production stays consistent.\n\n## Why It Matters\n\nManual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for curly quotes**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for ASCII hyphen and linting**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx`
- `/Users/la/Cycle-Ops/docs/changelog/authors.yml`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing final summary with code citations**

I’m gathering details on changed files, deciding to skip TODOs since the task is moderate but manageable, and planning to include concise code citations with relevant line snippets and comments to indicate truncation. I’ll structure the final message with a summary and next steps, noting optional image additions and omitting tests as not relevant.</details></think>

---

## Summary
- Added the new changelog post featuring Steve Kimoi’s guide to automating IC deployments with CycleOps and `ic-deploy-actions`, including setup steps and CTA for readers to try it out.  
```1:40:/Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx
---
slug: automate-canister-deployments
title: Automate Your Canister Deployments with CycleOps and ic-deploy-actions
authors: [steve]
---
Hi there, I'm Steve Kimoi, an ICP developer behind tools like generate-did and the DNS Config Generator. Today I'm walking through how CycleOps pairs with the ic-deploy-actions GitHub Action to make Internet Computer deployments hands-off.
<!-- truncate -->
Continuous delivery just got easier on the Internet Computer. With CycleOps orchestrating your canisters and ic-deploy-actions running in GitHub, every push to main can build, deploy, and monitor your project - no more terminal hops or manual dfx deploy.
## What We Shipped
- One-click automation: combine CycleOps with ic-deploy-actions to build, deploy, and watch canisters on every push.
- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.
- Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.
- Repeatable delivery: every merge follows the same scripted path, so production stays consistent.
## Why It Matters
Manual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.
```

- Registered Steve Kimoi in the changelog author roster so the new post attributes correctly.  
```19:28:/Users/la/Cycle-Ops/docs/changelog/authors.yml
quint:
  name: Quint Daenen
  title: Developer
  url: https://github.com/q-uint
  image_url: /img/authors/quint.png

steve:
  name: Steve Kimoi
  title: Developer / ICP Contributor
  url: https://github.com/Stephen-Kimoi
  image_url: /img/cycleops.png
```

## Next Steps
- Add hero/inline images for the post if you have assets you want to highlight.

---

_**User (2025-11-11 04:56Z)**_

@index.mdx (7-10) 



This part, I want you maintain it as it. And make it sound more human.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Rewriting introduction for clarity**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;8a3db4b7-588e-460f-950a-1a09e3e789a1&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  ---\n  \n- CI/CD pipelines just got a lot easier on the Internet Computer. \n+ CI/CD pipelines just got a lot easier on the Internet Computer.\n  \n- You can now easily automate deployments to production with CycleOps and &#96;ic-deploy-actions&#96;, every push to &#96;main&#96; can build, deploy, and monitor your project - no more terminal hops or manual &#96;dfx deploy&#96;.\n+ With CycleOps teaming up with &#96;ic-deploy-actions&#96;, every push to &#96;main&#96; can quietly build, deploy, and monitor your project -- no more terminal hopping or manual &#96;dfx deploy&#96;.\n  \n  &lt;!-- truncate --&gt;&quot;,
        &quot;oldStart&quot;: 5,
        &quot;newStart&quot;: 5,
        &quot;oldLines&quot;: 7,
        &quot;newLines&quot;: 7,
        &quot;linesRemoved&quot;: 2,
        &quot;linesAdded&quot;: 2
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\nCI/CD pipelines just got a lot easier on the Internet Computer.\n\nWith CycleOps teaming up with &#96;ic-deploy-actions&#96;, every push to &#96;main&#96; can quietly build, deploy, and monitor your project -- no more terminal hopping or manual &#96;dfx deploy&#96;.\n\n&lt;!-- truncate --&gt;\n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n## What We Shipped\n\n- One-click automation: combine CycleOps with &#96;ic-deploy-actions&#96; to build, deploy, and watch canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single service canister or orchestrate multi-canister projects with the same pipeline.\n- Repeatable delivery: every merge follows the same scripted path, so production stays consistent.\n\n## Why It Matters\n\nManual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Tweaked the intro at `changelog/2025-11-10-automate-canister-deployments/index.mdx` so it keeps the same message but reads more conversationally while highlighting CycleOps + `ic-deploy-actions` and the no-terminal deploy experience. Let me know if you want it pushed further in either direction.

---

_**User (2025-11-11 04:56Z)**_

I want you to act as a very experienced writer, who knows how to articulate words in a non-technical manner to their audience. 



This section over here @index.mdx (30-33)  sounds very robotic, AI generated and doesn't have a "human" touch. 



Please just make it simple, and easy to grasp. We don't want our readers to have to read through the statements twice for them to understand.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Revising deployment explanation**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;bf3a4c3c-6f11-4930-b7db-4f0319749f64&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  ## Why It Matters\n  \n- Manual deploys fall apart when teams grow or canister counts increase. This setup keeps your deployment logic in version control, prevents copy-paste mistakes, and lets you reuse familiar GitHub CI/CD primitives. The result is confidence that mainnet always reflects the code you just reviewed.\n+ Manual deploys can feel like juggling knives once your team or canister list grows. This setup puts the recipe in Git—no copy-paste scripts, no mystery steps—so you keep using the same GitHub Actions you&#39;re already comfortable with. The payoff is simple: what you merge is exactly what lands on mainnet.\n  \n  ## How You Can Use It&quot;,
        &quot;oldStart&quot;: 30,
        &quot;newStart&quot;: 30,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\n[![](./poster-3.png)](/changelog/automate-canister-deployments)\n\nCI/CD pipelines just got a lot easier on the Internet Computer.\n\nIn this post, I&#39;m going to show you how you can easily automate your deployments using &#96;&#96;CycleOps&#96;&#96; and &#96;&#96;IC Deploy Actions&#96;&#96;\n\nNo need to manually run dfx deploy command on your terminal, or spend hours configuring your custom github actions. Just plug in and use. \n\n&lt;!-- truncate --&gt;\n\n--- \n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n## What We Shipped\n\nYou can now easily automate your deployments to Internet Computer with these simple steps using [ic-deploy-actions](https://github.com/Stephen-Kimoi/ic-deploy-action) \n\n- With just simple steps automation, you&#39;re sorted for life: combination of &#96;&#96;CycleOps&#96;&#96; with &#96;ic-deploy-actions&#96; helps you build &amp; automatically deploy your canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single canister or multiple canisters within the same pipeline.\n- Repeatable delivery: every merge to the default branch automatically updates your production code, thus making you stay consistent. \n\n## Why It Matters\n\nManual deploys can feel like juggling knives once your team or canister list grows. This setup puts the recipe in Git—no copy-paste scripts, no mystery steps—so you keep using the same GitHub Actions you&#39;re already comfortable with. The payoff is simple: what you merge is exactly what lands on mainnet.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Simplifying deployment explanation**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;4f1a06a1-31c5-4e35-9593-139288f4a9a9&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  ## Why It Matters\n  \n- Manual deploys can feel like juggling knives once your team or canister list grows. This setup puts the recipe in Git—no copy-paste scripts, no mystery steps—so you keep using the same GitHub Actions you&#39;re already comfortable with. The payoff is simple: what you merge is exactly what lands on mainnet.\n+ Manual deploys stop being fun once more people or canisters join the project. This workflow keeps every step in Git, removes copy-paste scripts, and leans on the GitHub Actions you already know. The result? Whatever you merge is what runs on mainnet, every time.\n  \n  ## How You Can Use It&quot;,
        &quot;oldStart&quot;: 30,
        &quot;newStart&quot;: 30,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\n[![](./poster-3.png)](/changelog/automate-canister-deployments)\n\nCI/CD pipelines just got a lot easier on the Internet Computer.\n\nIn this post, I&#39;m going to show you how you can easily automate your deployments using &#96;&#96;CycleOps&#96;&#96; and &#96;&#96;IC Deploy Actions&#96;&#96;\n\nNo need to manually run dfx deploy command on your terminal, or spend hours configuring your custom github actions. Just plug in and use. \n\n&lt;!-- truncate --&gt;\n\n--- \n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n## What We Shipped\n\nYou can now easily automate your deployments to Internet Computer with these simple steps using [ic-deploy-actions](https://github.com/Stephen-Kimoi/ic-deploy-action) \n\n- With just simple steps automation, you&#39;re sorted for life: combination of &#96;&#96;CycleOps&#96;&#96; with &#96;ic-deploy-actions&#96; helps you build &amp; automatically deploy your canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single canister or multiple canisters within the same pipeline.\n- Repeatable delivery: every merge to the default branch automatically updates your production code, thus making you stay consistent. \n\n## Why It Matters\n\nManual deploys stop being fun once more people or canisters join the project. This workflow keeps every step in Git, removes copy-paste scripts, and leans on the GitHub Actions you already know. The result? Whatever you merge is what runs on mainnet, every time.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Running lint checks**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Rewrote the “Why It Matters” paragraph at `changelog/2025-11-10-automate-canister-deployments/index.mdx` to keep the idea but say it plainly and conversationally: manual deploys don’t scale, this workflow keeps the steps in Git using the Actions folks already know, and every merge now matches what lands on mainnet. Let me know if you want to tweak the tone further.

---

_**User (2025-11-11 04:56Z)**_

No, that is not what I want. That just sounds like a poem now. 



It needs to be simple. Like "Manual deployments are cumbersome when the project grows and your team size increases. This workflow simplifies...." 



Something of the sort. 



Please just make it simple, no poetry, no AI generated words. Just human friendly. 

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Requesting plain text format**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;ed49e544-f22b-4dee-8edf-9ca8164ff0f7&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  ## Why It Matters\n  \n- Manual deploys stop being fun once more people or canisters join the project. This workflow keeps every step in Git, removes copy-paste scripts, and leans on the GitHub Actions you already know. The result? Whatever you merge is what runs on mainnet, every time.\n+ Manual deployments get messy when your project or team grows. This workflow keeps every step in Git, removes copy-paste scripts, and uses familiar GitHub Actions. What you merge is what goes live on mainnet.\n  \n  ## How You Can Use It&quot;,
        &quot;oldStart&quot;: 30,
        &quot;newStart&quot;: 30,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM changelog/2025-11-10-automate-canister-deployments/index.mdx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;---\nslug: automate-canister-deployments\ntitle: Automate Your Canister Deployments with CycleOps and ic-deploy-actions\nauthors: [steve]\n---\n\n[![](./poster-3.png)](/changelog/automate-canister-deployments)\n\nCI/CD pipelines just got a lot easier on the Internet Computer.\n\nIn this post, I&#39;m going to show you how you can easily automate your deployments using &#96;&#96;CycleOps&#96;&#96; and &#96;&#96;IC Deploy Actions&#96;&#96;\n\nNo need to manually run dfx deploy command on your terminal, or spend hours configuring your custom github actions. Just plug in and use. \n\n&lt;!-- truncate --&gt;\n\n--- \n\nHi there, I&#39;m Steve Kimoi, an ICP developer behind tools like [generate-did](https://crates.io/crates/generate-did) and the [DNS Config Generator](https://canisterdns.stevekimoi.me/). Today I&#39;m walking through how CycleOps pairs with the [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) GitHub Action to make Internet Computer deployments hands-off.\n\n## What We Shipped\n\nYou can now easily automate your deployments to Internet Computer with these simple steps using [ic-deploy-actions](https://github.com/Stephen-Kimoi/ic-deploy-action) \n\n- With just simple steps automation, you&#39;re sorted for life: combination of &#96;&#96;CycleOps&#96;&#96; with &#96;ic-deploy-actions&#96; helps you build &amp; automatically deploy your canisters on every push.\n- Secure auth: PEM keys are stored in GitHub Secrets, keeping credentials out of source control.\n- Flexible workflows: ship a single canister or multiple canisters within the same pipeline.\n- Repeatable delivery: every merge to the default branch automatically updates your production code, thus making you stay consistent. \n\n## Why It Matters\n\nManual deployments get messy when your project or team grows. This workflow keeps every step in Git, removes copy-paste scripts, and uses familiar GitHub Actions. What you merge is what goes live on mainnet.\n\n## How You Can Use It\n\n### 1. Create or Add a Canister in CycleOps\n\n- Spin up the canister from your CycleOps dashboard - full docs live [here](https://docs.cycleops.dev/changelog/canister-creation).\n- Run a one-time deploy from your workstation so the canister has initial code on mainnet.\n\n### 2. Wire Up &#96;ic-deploy-actions&#96;\n\nCreate &#96;.github/workflows/deploy.yml&#96; in your repo and paste in this workflow:\n\n&#96;&#96;&#96;yml\nname: Deploy to IC\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to IC\n        uses: Stephen-Kimoi/ic-deploy-action/action@v0.1.1\n        with:\n          pem_key: ${{ secrets.IC_PEM_KEY }}\n          network: ic\n          canister_name: your_backend_canister_name\n          deploy_frontend: \&quot;true\&quot;\n          deploy_backend: \&quot;true\&quot;\n          frontend_dir: src/your_frontend_dir/dist\n          backend_package: your_backend_package\n          frontend_package: your_frontend_package\n          frontend_src_dir: src/your_frontend_dir\n&#96;&#96;&#96;\n\nGenerate a PEM key and add it to your GitHub secrets:\n\n&#96;&#96;&#96;bash\ndfx identity new cicd-identity --storage-mode=plaintext\ndfx identity export cicd-identity &gt; cicd-identity.pem\nbase64 -i cicd-identity.pem &gt; cicd-identity.pem.base64\n&#96;&#96;&#96;\n\nCopy the Base64 output into a &#96;IC_PEM_KEY&#96; repository secret and you&#39;re done.\n\nThat&#39;s it - every push to &#96;main&#96; now ships straight to the Internet Computer. CycleOps handles monitoring and top-ups, while &#96;ic-deploy-actions&#96; keeps builds and deployments flowing.\n\n---\n\n### ✅ Ready to try it?\n\n1. [Create a canister in CycleOps](https://docs.cycleops.dev/changelog/canister-creation)\n2. Add [&#96;ic-deploy-actions&#96;](https://github.com/Stephen-Kimoi/ic-deploy-action) to your repo\n3. Push to &#96;main&#96; and watch your deployment go live&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---



---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/la/Cycle-Ops/docs/changelog/2025-11-10-automate-canister-deployments/index.mdx`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Updated the “Why It Matters” paragraph at `changelog/2025-11-10-automate-canister-deployments/index.mdx` to plain, straightforward wording: manual deployments become cumbersome as teams grow, and this workflow keeps steps in Git with familiar GitHub Actions so whatever you merge is what hits mainnet. Let me know if you’d like any more refinements.

---

